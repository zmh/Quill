name: Release

on:
  push:
    tags:
      - 'v*.*.*'  # Trigger on version tags like v1.0.0

jobs:
  build-and-release:
    name: Build and Release macOS App
    runs-on: macos-14  # Latest macOS runner
    permissions:
      contents: write  # Required to create releases

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Full history for changelog generation

      - name: Setup Xcode
        uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: '16.1'  # Project format 77 requires Xcode 16+

      - name: Import Code Signing Certificate
        env:
          CERTIFICATE_BASE64: ${{ secrets.APPLE_CERTIFICATE_BASE64 }}
          CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
        run: |
          # Create temporary keychain
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          KEYCHAIN_PASSWORD=$(openssl rand -base64 32)

          # Create keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Import certificate
          CERTIFICATE_PATH=$RUNNER_TEMP/certificate.p12
          echo "$CERTIFICATE_BASE64" | base64 --decode > "$CERTIFICATE_PATH"
          security import "$CERTIFICATE_PATH" -P "$CERTIFICATE_PASSWORD" -A -t cert -f pkcs12 -k "$KEYCHAIN_PATH"

          # Set keychain as default
          security list-keychain -d user -s "$KEYCHAIN_PATH"
          security set-key-partition-list -S apple-tool:,apple:,codesign: -s -k "$KEYCHAIN_PASSWORD" "$KEYCHAIN_PATH"

          # Clean up certificate file
          rm "$CERTIFICATE_PATH"

          echo "Certificate imported successfully"

      - name: Extract version from tag
        id: version
        run: |
          VERSION=${GITHUB_REF#refs/tags/v}
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "Building version: $VERSION"

      - name: Build Release
        env:
          DEVELOPMENT_TEAM: ${{ secrets.APPLE_TEAM_ID }}
          CODE_SIGN_IDENTITY: "Developer ID Application"
        run: |
          chmod +x Scripts/build-release.sh
          ./Scripts/build-release.sh ${{ steps.version.outputs.version }}

      - name: Create DMG
        env:
          CODE_SIGN_IDENTITY: "Developer ID Application"
        run: |
          chmod +x Scripts/create-dmg.sh
          ./Scripts/create-dmg.sh ${{ steps.version.outputs.version }}

      - name: Generate Release Notes
        id: release_notes
        run: |
          # Get the previous tag
          PREV_TAG=$(git describe --abbrev=0 --tags $(git rev-list --tags --skip=1 --max-count=1) 2>/dev/null || echo "")

          # Generate changelog
          if [ -n "$PREV_TAG" ]; then
            echo "## What's Changed" > release_notes.md
            echo "" >> release_notes.md
            git log ${PREV_TAG}..HEAD --pretty=format:"- %s (%h)" >> release_notes.md
          else
            echo "Initial release" > release_notes.md
          fi

          echo "" >> release_notes.md
          echo "" >> release_notes.md
          echo "## Installation" >> release_notes.md
          echo "" >> release_notes.md
          echo "1. Download \`Quill-${{ steps.version.outputs.version }}.dmg\`" >> release_notes.md
          echo "2. Open the DMG file" >> release_notes.md
          echo "3. Drag Quill to your Applications folder" >> release_notes.md
          echo "4. Launch Quill from Applications" >> release_notes.md
          echo "" >> release_notes.md
          echo "## Verification" >> release_notes.md
          echo "" >> release_notes.md
          echo "SHA256 checksum:" >> release_notes.md
          echo "\`\`\`" >> release_notes.md
          cat build/Quill-${{ steps.version.outputs.version }}.dmg.sha256 >> release_notes.md
          echo "\`\`\`" >> release_notes.md

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          files: |
            build/Quill-${{ steps.version.outputs.version }}.dmg
            build/Quill-${{ steps.version.outputs.version }}.dmg.sha256
          body_path: release_notes.md
          draft: false
          prerelease: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate Appcast
        run: |
          # Create appcast directory if it doesn't exist
          mkdir -p build/appcast

          # Generate appcast entry
          VERSION="${{ steps.version.outputs.version }}"
          DMG_SIZE=$(stat -f%z "build/Quill-${VERSION}.dmg")
          DATE=$(date -u +"%a, %d %b %Y %H:%M:%S %z")
          DOWNLOAD_URL="https://github.com/${{ github.repository }}/releases/download/v${VERSION}/Quill-${VERSION}.dmg"

          # Note: In production, you would sign the release with EdDSA
          # For now, we create the structure without signatures
          cat > "build/appcast/appcast.xml" << EOF
          <?xml version="1.0" encoding="utf-8"?>
          <rss version="2.0" xmlns:sparkle="http://www.andymatuschak.org/xml-namespaces/sparkle">
              <channel>
                  <title>Quill Updates</title>
                  <description>Most recent updates to Quill</description>
                  <language>en</language>
                  <item>
                      <title>Version ${VERSION}</title>
                      <pubDate>${DATE}</pubDate>
                      <sparkle:version>${VERSION}</sparkle:version>
                      <sparkle:shortVersionString>${VERSION}</sparkle:shortVersionString>
                      <description><![CDATA[
                          <h2>What's New in ${VERSION}</h2>
                          <p>See the <a href="https://github.com/${{ github.repository }}/releases/tag/v${VERSION}">release notes</a> for details.</p>
                      ]]></description>
                      <enclosure
                          url="${DOWNLOAD_URL}"
                          length="${DMG_SIZE}"
                          type="application/octet-stream"
                      />
                      <sparkle:minimumSystemVersion>14.0</sparkle:minimumSystemVersion>
                  </item>
              </channel>
          </rss>
          EOF

          echo "Appcast generated at build/appcast/appcast.xml"

      - name: Upload Appcast as Artifact
        uses: actions/upload-artifact@v4
        with:
          name: appcast
          path: build/appcast/appcast.xml

      - name: Sign DMG with Sparkle EdDSA
        env:
          SPARKLE_PRIVATE_KEY: ${{ secrets.SPARKLE_EDDSA_PRIVATE_KEY }}
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          DMG_PATH="build/Quill-${VERSION}.dmg"

          # Download Sparkle tools for signing
          SPARKLE_VERSION="2.6.4"
          SPARKLE_URL="https://github.com/sparkle-project/Sparkle/releases/download/${SPARKLE_VERSION}/Sparkle-${SPARKLE_VERSION}.tar.xz"

          echo "Downloading Sparkle tools..."
          curl -L -o "$RUNNER_TEMP/sparkle.tar.xz" "$SPARKLE_URL"
          tar -xf "$RUNNER_TEMP/sparkle.tar.xz" -C "$RUNNER_TEMP"

          # Find sign_update tool (it's in Sparkle.framework/Resources/bin/)
          SIGN_UPDATE=$(find "$RUNNER_TEMP" -name "sign_update" -type f | head -1)

          if [ ! -f "$SIGN_UPDATE" ]; then
            echo "Error: sign_update tool not found"
            echo "Contents of RUNNER_TEMP:"
            ls -laR "$RUNNER_TEMP" | head -100
            exit 1
          fi

          echo "Found sign_update at: $SIGN_UPDATE"
          chmod +x "$SIGN_UPDATE"

          # Write private key to temporary file
          PRIVATE_KEY_PATH="$RUNNER_TEMP/sparkle_private_key"
          echo "$SPARKLE_PRIVATE_KEY" > "$PRIVATE_KEY_PATH"

          # Sign the DMG and capture the signature
          SIGNATURE=$("$SIGN_UPDATE" "$DMG_PATH" "$PRIVATE_KEY_PATH")

          # Save signature to file for next step
          echo "$SIGNATURE" > build/dmg_signature.txt
          echo "EdDSA Signature: $SIGNATURE"

          # Clean up private key and tools
          rm "$PRIVATE_KEY_PATH"
          rm -rf "$RUNNER_TEMP/sparkle.tar.xz"

      - name: Update Appcast in Repository
        run: |
          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Fetch and checkout main branch
          git fetch origin main
          git checkout main

          # Get release info
          VERSION="${{ steps.version.outputs.version }}"
          DMG_SIZE=$(stat -f%z "build/Quill-${VERSION}.dmg")
          ED_SIGNATURE=$(cat build/dmg_signature.txt)

          # Make script executable
          chmod +x Scripts/update-appcast.py

          # Update appcast.xml using the Python script with EdDSA signature
          python3 Scripts/update-appcast.py "$VERSION" "$DMG_SIZE" "release_notes.md" "$ED_SIGNATURE"

          # Commit and push if there are changes
          if git diff --quiet appcast.xml; then
            echo "No changes to appcast.xml"
          else
            git add appcast.xml
            git commit -m "Update appcast.xml for v${VERSION} [skip ci]"
            git push origin main
            echo "Appcast updated and pushed to main branch"
          fi

  notify:
    name: Notify Release Complete
    needs: build-and-release
    runs-on: ubuntu-latest
    steps:
      - name: Summary
        run: |
          echo "### Release Complete! ðŸŽ‰" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "Version ${{ needs.build-and-release.outputs.version }} has been built and released." >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Next Steps:**" >> $GITHUB_STEP_SUMMARY
          echo "1. âœ… appcast.xml automatically updated on main branch" >> $GITHUB_STEP_SUMMARY
          echo "2. Test the release by downloading from GitHub" >> $GITHUB_STEP_SUMMARY
          echo "3. Verify Sparkle updates are working" >> $GITHUB_STEP_SUMMARY
          echo "4. Announce the release to users" >> $GITHUB_STEP_SUMMARY
